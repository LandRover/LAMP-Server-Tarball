######################################################################
#                      Exim configuration file                       #
######################################################################

CONFDIR = /opt/local/etc/exim

keep_environment = MAIN_KEEP_ENVIRONMENT
DCconfig_internet = true
# DCconfig_local = true
# DCconfig_mailgun = true
# DISABLE_DKIM_VERIFY = true
#CHECK_RCPT_DMARC = true
CHECK_DATA_SFP = true
CHECK_DATA_MALWARE = true

log_selector = -tls_certificate_verified

domainlist local_domains = lsearch;CONFDIR/virtual/domains_local
domainlist relay_to_domains = lsearch;CONFDIR/virtual/domains_local
hostlist relay_from_hosts = 127.0.0.1
hostlist whitelist = lsearch;CONFDIR/virtual/whitelist_hosts
hostlist spammers = net-iplsearch;CONFDIR/virtual/spammers
local_from_check = false
local_sender_retain = true
untrusted_set_sender = *
av_scanner = clamd:/var/run/clamav/clamd.ctl
#spamd_address = 127.0.0.1 783

# SSL/TLS cert and key
MAIN_TLS_VERIFY_CERTIFICATES = /opt/local/etc/openssl/certs/cacert.pem
tls_advertise_hosts = *
tls_privatekey = CONFDIR/ssl/exim.key
tls_certificate = CONFDIR/ssl/exim.cert
tls_require_ciphers = HIGH:+TLSv1:!SSLv2:!SSLv3
tls_try_verify_hosts = *
openssl_options = +dont_insert_empty_fragments +no_sslv2 +no_sslv3

# GNUTLS
.ifdef _HAVE_GNUTLS
  tls_dhparam = historic
  gnutls_require_protocols = !SSLv2:!SSLv3:TLSv1
.endif

daemon_smtp_ports = 25 : 465 : 587 : 2525
tls_on_connect_ports = 465
never_users = root
host_lookup = *
rfc1413_hosts = *
rfc1413_query_timeout = 5s
prdr_enable = true
ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d

freeze_tell=postmaster

# OPTS: mail_spool | maildir_home
LOCAL_DELIVERY=maildir_home

# ACL
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data
acl_smtp_connect = acl_check_connect
acl_smtp_mail = acl_check_mail
acl_smtp_dkim = acl_check_dkim


# The gecos field in /etc/passwd holds not only the name. see passwd(5).
gecos_pattern = ^([^,:]*)
gecos_name = $1

dkim_verify_signers = $sender_address_domain:$dkim_signers

######################################################################
#                       ACL CONFIGURATION                            #
#         Specifies access control lists for incoming SMTP mail      #
######################################################################
begin acl

acl_check_dkim:
  accept authenticated = *

  warn    set acl_m0  = $tod_epoch

  # Warn no DKIM
  warn    dkim_status = none
          set acl_c4  = X-DKIM-Warning: No signature found

  # RFC 8301 requires 'permanently failed evaluation' for DKIM signatures signed with 'historic algorithms (currently, rsa-sha1)'
  # @SEE: https://www.exim.org/exim-html-current/doc/html/spec_html/ch-dkim_and_spf.html
  warn    condition              = ${if !def:acl_c4 {true}{false}}
          condition              = ${if eq {$dkim_verify_status}{pass}}
          condition              = ${if eq {${length_3:$dkim_algo} }{rsa}}
          condition              = ${if or { {eq {$dkim_algo}{rsa-sha1}} \
                                    {< {$dkim_key_length}{1024}} }}
          set acl_c4             = X-DKIM-Warning: forced DKIM failure (weak hash or short key)
          set dkim_verify_status = fail
          set dkim_verify_reason = hash too weak or key too short

  # RFC6376 requires that verification fail if the From: header is not included in the signature
  # @SEE: https://www.exim.org/exim-html-current/doc/html/spec_html/ch-dkim_and_spf.html
  warn    condition   = ${if !def:acl_c4 {true}{false} }
          condition   = ${if !inlist{from}{$dkim_headernames}{true}{false} }
          set acl_c4  = X-DKIM-Warning: From: header not included in the \
                        signature, this defies the purpose of DKIM

  # Warn invalid or failed signatures
  warn    condition   = ${if !def:acl_c4 {true}{false}}
          dkim_status = fail:invalid
          set acl_c4  = X-DKIM-Warning: verifying signature of $dkim_cur_signer \
                        failed for $sender_address because $dkim_verify_reason

  # Add a DKIM-Received: line to the message header (regardless of DKIM status)
  warn    add_header  = Received-DKIM: $dkim_verify_status${if \
                        def:dkim_algo { ($dkim_cur_signer with \
                        $dkim_algo for $dkim_headernames)}}

  # Set up for finalisation: add header and write to log
  warn    condition   = ${if def:acl_c4 {true}{false}}
          add_header  = $acl_c4
          logwrite    = $acl_c4

  # On error: accept but stall (good actors tend to be patient)
  accept  set acl_m0  = ${if def:acl_c4 {${eval:20 + $acl_m0 - $tod_epoch}}{0}}
          #delay       = ${if >{$acl_m0}{0}{$acl_m0}{0}}s
          delay        = 0s


acl_local_deny_exceptions:
  accept  hosts         = ${if exists{CONFDIR/virtual/host_local_deny_exceptions}\
                              {CONFDIR/virtual/host_local_deny_exceptions}\
                          {}}

  accept  senders       = ${if exists{CONFDIR/virtual/sender_local_deny_exceptions}\
                              {CONFDIR/virtual/sender_local_deny_exceptions}\
                          {}}

  accept  hosts         = ${if exists{CONFDIR/virtual/local_host_whitelist}\
                              {CONFDIR/virtual/local_host_whitelist}\
                          {}}

  accept  senders       = ${if exists{CONFDIR/virtual/local_sender_whitelist}\
                              {CONFDIR/virtual/local_sender_whitelist}\
                          {}}


acl_check_connect:
  accept  hosts         = +whitelist

  drop    message       = Your host in blacklist on this server.
          log_message   = Host in blacklist
          hosts         = +spammers

  accept


acl_check_mail:
  deny    condition     = ${if eq{$sender_helo_name}{}}
          message       = HELO required before MAIL

  drop    message       = Helo name contains a ip address (HELO was $sender_helo_name) and not is valid
          condition     = ${if match{$sender_helo_name}{\N((\d{1,3}[.-]\d{1,3}[.-]\d{1,3}[.-]\d{1,3})|([0-9a-f]{8})|([0-9A-F]{8}))\N}{yes}{no}}
          condition     = ${if match {${lookup dnsdb{>: defer_never,ptr=$sender_host_address}}\}{$sender_helo_name}{no}{yes}}
          delay         = 45s

  drop    condition     = ${if isip{$sender_helo_name}}
          message       = Access denied - Invalid HELO name (See RFC2821 4.1.3)

  drop    condition     = ${if eq{[$interface_address]}{$sender_helo_name}}
          message       = $interface_address is _my_ address

  accept


acl_check_rcpt:
  accept  hosts         = :
          control       = dkim_disable_verify

  .ifdef DISABLE_DKIM_VERIFY
    warn  control       = dkim_disable_verify
  .endif

  deny    message       = Restricted characters in address
          domains       = +local_domains
          local_parts   = ^[.] : ^.*[@%!/|`#&?]

  deny    message       = Restricted characters in address
          domains       = !+local_domains
          local_parts   = ^[./|] : ^.*[@%!`#&?] : ^.*/\\.\\./

  accept  domains       = +local_domains : +relay_to_domains
          local_parts   = postmaster

  require verify        = sender
  require verify        = recipient

  accept  hosts         = +relay_from_hosts
          control       = submission/sender_retain
          control       = dkim_disable_verify

  accept  authenticated = *
          control       = submission/sender_retain
          control       = dkim_disable_verify

  require message       = nice hosts say HELO first
          condition     = ${if def:sender_helo_name}

  deny    message       = Rejected because $sender_host_address is in a black list at $dnslist_domain\n$dnslist_text
          hosts         = !+whitelist
          dnslists      = ${readfile {CONFDIR/virtual/dnsbl.conf}{:}}

  require message       = relay not permitted
          domains       = +local_domains : +relay_to_domains

  deny    message       = smtp auth requried
          sender_domains= +local_domains
          !authenticated= *

  deny    message       = sender envelope address $sender_address is locally blacklisted here. If you think this is wrong, get in touch with postmaster
          !acl          = acl_local_deny_exceptions
          senders       = ${if exists{CONFDIR/virtual/blacklist_sender}\
                                     {CONFDIR/virtual/blacklist_sender}\
                          {}}

  deny    message       = sender IP address $sender_host_address is locally blacklisted here. If you think this is wrong, get in touch with postmaster
          !acl          = acl_local_deny_exceptions
          hosts         = ${if exists{CONFDIR/virtual/blacklist_host}\
                                     {CONFDIR/virtual/blacklist_host}\
                          {}}

  .ifdef CHECK_RCPT_REVERSE_DNS
    warn  condition     = ${if and{{def:sender_host_address}{!def:sender_host_name}}\
                                     {yes}{no}}
                          add_header = X-Host-Lookup-Failed: Reverse DNS lookup failed for $sender_host_address (${if eq{$host_lookup_failed}{1}{failed}{deferred}})
  .endif


  .ifdef CHECK_RCPT_SPF
    deny  message      = [SPF] $sender_host_address is not allowed to send mail from \
                          ${if def:sender_address_domain {$sender_address_domain}{$sender_helo_name}}.  \
                          Please see \
                          http://www.openspf.org/Why?scope=${if def:sender_address_domain \
                          {mfrom}{helo}};identity=${if def:sender_address_domain \
                          {$sender_address}{$sender_helo_name}};ip=$sender_host_address
          log_message  = SPF check failed.
          !acl         = acl_local_deny_exceptions
          condition    = ${run{/usr/bin/spfquery.mail-spf-perl --ip \
                         ${quote:$sender_host_address} --identity \
                         ${if def:sender_address_domain \
                         {--scope mfrom  --identity ${quote:$sender_address}}\
                         {--scope helo --identity ${quote:$sender_helo_name}}}}\
                         {no}{${if eq {$runrc}{1}{yes}{no}}}}

    defer message      = Temporary DNS error while checking SPF record.  Try again later.
          !acl         = acl_local_deny_exceptions
          condition    = ${if eq {$runrc}{5}{yes}{no}}

    warn  condition    = ${if <={$runrc}{6}{yes}{no}}
                         add_header = Received-SPF: ${if eq {$runrc}{0}{pass}\
                                        {${if eq {$runrc}{2}{softfail}\
                                        {${if eq {$runrc}{3}{neutral}\
                                        {${if eq {$runrc}{4}{permerror}\
                                        {${if eq {$runrc}{6}{none}{error}}}}}}}}}\
                                      } client-ip=$sender_host_address; \
                                      ${if def:sender_address_domain \
                                      {envelope-from=${sender_address}; }{}}\
                                      helo=$sender_helo_name

    warn  log_message = Unexpected error in SPF check.
          condition   = ${if >{$runrc}{6}{yes}{no}}
  .endif


  .ifdef CHECK_RCPT_DMARC
    warn  domains      = +local_domains
          hosts        = +local_hosts
          control      = dmarc_disable_verify

    warn  !domains     = +screwed_up_dmarc_records
          control      = dmarc_enable_forensic

    warn  condition    = (lookup if destined to mailing list)
          set acl_m_mailing_list = 1
  .endif


  .ifdef CHECK_RCPT_IP_DNSBLS
    warn  dnslists    = CHECK_RCPT_IP_DNSBLS
          add_header  = X-Warning: $sender_host_address is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
          log_message = $sender_host_address is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
  .endif

  .ifdef CHECK_RCPT_DOMAIN_DNSBLS
    warn  !senders    = ${if exists{CONFDIR/virtual/domain_dnsbl_whitelist}\
                            {CONFDIR/virtual/domain_dnsbl_whitelist}\
                        {}}
          dnslists    = CHECK_RCPT_DOMAIN_DNSBLS
          add_header  = X-Warning: $sender_address_domain is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
          log_message = $sender_address_domain is listed at $dnslist_domain ($dnslist_value: $dnslist_text)
  .endif

  .ifdef CHECK_RCPT_LOCAL_ACL_FILE
    .include CHECK_RCPT_LOCAL_ACL_FILE
  .endif

  accept  domains    = +relay_to_domains
          endpass
          verify     = recipient

  accept


acl_check_data:
  deny    message    = maximum allowed line length is 998 octets, \
                       got $max_received_linelength
          condition  = ${if > {$max_received_linelength}{998}}

  warn    condition                     = ${if !def:h_Message-ID: {1}}
          condition                     = ${if eq{GREYLIST}{YES}{yes}{no}}
          set acl_m_greylistreasons     = Message lacks Message-Id: header. Consult RFC2822.\n $acl_m_greylistreasons

  .ifdef CHECK_DATA_VERIFY_HEADER_SYNTAX
    deny  message    = Message headers fail syntax check
          !acl       = acl_local_deny_exceptions
          !verify    = header_syntax
  .endif

  .ifdef CHECK_DATA_VERIFY_HEADER_SENDER
    deny  message    = No verifiable sender address in message headers
          !acl       = acl_local_deny_exceptions
          !verify    = header_sender
  .endif

  .ifdef CHECK_DATA_MALWARE
    # Reject if ClamAV detects malware
    deny  condition  = ${if eq{CLAMENABLED}{on}{yes}{no}}
          message    = This message contains malware ($malware_name)
          malware    = *
          log_message= This message contains malware ($malware_name)

    # Set variables up for router to use for acl_m_bu_mxhost value.
    warn  set acl_m_bu_mxhost = 0

    # Set variables up for router to use for mail relayed by backup_mx_hosts
    warn  hosts               = +whitelist
          set acl_m_spamscore = ${eval10:${extract{-1}{\n}{$h_X-Spam-Score-Integer:}}+0}
          set acl_m_bu_mxhost = 1
          log_message         = ACL Spamscore: $acl_m_spamscore computed from backup MX hosts Spam Score Integer: $h_X-Spam-Score-Integer
  .endif

  accept  hosts = +whitelist : +relay_from_hosts

  accept  hosts = :

  .ifdef CHECK_DATA_SFP
    deny  hosts = ! +relay_from_hosts
          hosts = ! +whitelist
          !hosts= :
          !acl  = spf_from_acl
          message            = Your sender is not permitted (SPF - read spf.pobox.com)
          log_message        = From address not permitted - SPF.
          !authenticated     = *
  .endif

  .ifdef CHECK_RCPT_DMARC
    warn  dmarc_status   = accept : none : off
          !authenticated = *
          log_message    = DMARC DEBUG: $dmarc_status $dmarc_used_domain

    warn    dmarc_status   = !accept
          !authenticated = *
          log_message    = DMARC DEBUG: '$dmarc_status' for $dmarc_used_domain

    warn  dmarc_status   = quarantine
          !authenticated = *
          set $acl_m_quarantine = 1
          # Do something in a transport with this flag variable

    deny  condition      = ${if eq{$dmarc_domain_policy}{reject}}
          condition      = ${if eq{$acl_m_mailing_list}{1}}
          message        = Messages from $dmarc_used_domain break mailing lists

    deny  dmarc_status   = reject
          !authenticated = *
          message        = Message from $dmarc_used_domain failed sender's DMARC policy, REJECT

    warn    add_header   = :at_start:${authresults {$primary_hostname}}
  .endif

  .ifdef _CHECK_DATA_RBL
    # SURBL/URIBL URL Check for blacklisted URL links embeded in mail.
    # This only checks non-mime emails via the second condition statement
    # Perl Script Scans 100K of Message
    deny  condition      = ${if eq{URIBLOCK}{YES}{yes}{no}}
          condition      = ${if <{$message_size}{100000}{yes}{no}}
          condition      = ${if eq{$acl_m0}{}{yes}{no}}
          set acl_m1     = ${perl{surblspamcheck}}
          condition      = ${if eq{$acl_m1}{false}{no}{yes}}
          message        = $acl_m1
  .endif

  .ifdef _CHECK_DATA_SPAM_SCORE
    warn
      spam = exim:true
      add_header = X-Spam_score: $spam_score\n\
                X-Spam_score_int: $spam_score_int\n\
                X-Spam_bar: $spam_bar\n\
                X-Spam_report: $spam_report
  .endif

  accept


acl_check_mime:
  deny   message     = Blacklisted file extension detected
         condition   = ${if match {${lc:$mime_filename}}{\N(\.ade|\.adp|\.bat|\.chm|\.cmd|\.com|\.cpl|\.exe|\.hta|\.ins|\.isp|\.jse|\.lib|\.lnk|\.mde|\.msc|\.msp|\.mst|\.pif|\.scr|\.sct|\.shb|\.sys|\.vb|\.vbe|\.vbs|\.vxd|\.wsc|\.wsf|\.wsh)$\N}{1}{0}}

  accept


spf_from_acl:

    # Check header From:
    warn     set acl_m8  = ${address:$h_from:}
    deny     !acl        = spf_check
    warn     message     = Received-SPF: $acl_m7
    accept

spf_check:

    warn     set acl_m9  = ${readsocket{/var/run/spfd.sock}\
                           {ip=$sender_host_address\n\
                           helo=${if def:sender_helo_name\
                           {$sender_helo_name}{NOHELO}}\
                           \nsender=$acl_m8\n\n}{20s}{\n}{socket failure}}

    # Defer on socket error

    defer    condition   = ${if eq{$acl_m9}{socket failure}{yes}{no}}
             message     = Cannot connect to spfd.sock, is it running?

    # Prepare answer and get results

    warn     set acl_m9  = ${sg{$acl_m9}{\N=(.*)\n\N}{=\"\$1\" }}
             set acl_m8  = ${extract{result}{$acl_m9}{$value}{unknown}}
             set acl_m7  = ${extract{header_comment}{$acl_m9}{$value}{}}

    # Check for fail

    deny     condition   = ${if eq{$acl_m8}{fail}{yes}{no}}
             message     = $acl_m7
             log_message = Not authorized by SPF

    accept


######################################################################
#                   AUTHENTICATION CONFIGURATION                     #
######################################################################
begin authenticators

.ifdef DCconfig_mailgun

  auth_login:
    driver = plaintext
    public_name = LOGIN
    hide client_send = ": postmaster@mailgun.com : password"

.endif


cram_md5:
  driver = cram_md5
  public_name = CRAM-MD5
  client_name = ${extract{1}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}
  client_secret = ${extract{2}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}


# this returns the matching line from passwd.client and doubles all ^
PASSWDLINE=${sg{\
                ${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}\
            }\
            {\\N[\\^]\\N}\
            {^^}\
        }

plain:
  driver = plaintext
  public_name = PLAIN
  .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
    client_send = "<; ${if !eq{$tls_out_cipher}{}\
                    {^${extract{1}{:}{PASSWDLINE}}\
                    ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}\
                    }fail}"
  .else
    client_send = "<; ^${extract{1}{:}{PASSWDLINE}}\
                    ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
  .endif


login:
  driver = plaintext
  public_name = LOGIN

  .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
    # Return empty string if not non-TLS AND looking up $host in passwd-file
    # yields a non-empty string; fail otherwise.
    client_send = "<; ${if and{\
                          {!eq{$tls_out_cipher}{}}\
                          {!eq{PASSWDLINE}{}}\
                         }\
                      {}fail}\
                   ; ${extract{1}{::}{PASSWDLINE}}\
                   ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
  .else
    # Return empty string if looking up $host in passwd-file yields a
    # non-empty string; fail otherwise.
    client_send = "<; ${if !eq{PASSWDLINE}{}\
                      {}fail}\
                     ; ${extract{1}{::}{PASSWDLINE}}\
                   ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
  .endif



######################################################################
#                      ROUTERS CONFIGURATION                         #
#               Specifies how addresses are handled                  #
######################################################################
begin routers

.ifdef DCconfig_internet

  dnslookup_relay_to_domains:
    debug_print = "DEBUG R: dnslookup_relay_to_domains for $local_part@$domain"
    driver = dnslookup
    domains = ! +local_domains : +relay_to_domains
    transport = remote_smtp
    same_domain_copy_routing = yes
    no_more


  dnslookup:
    debug_print = "DEBUG R: dnslookup for $local_part@$domain"
    driver = dnslookup
    domains = ! +local_domains
    transport = remote_smtp
    same_domain_copy_routing = yes
    # ignore private rfc1918 and APIPA addresses
    ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8 : 192.168.0.0/16 :\
                  172.16.0.0/12 : 10.0.0.0/8 : 169.254.0.0/16 :\
                  255.255.255.255
    no_more

.endif


.ifdef DCconfig_mailgun

  mailgun:
    driver = manualroute
    domains = ! +local_domains
    transport = mailgun_smtp
    route_list = * smtp.mailgun.org byname

.endif


.ifdef DCconfig_local

  nonlocal:
    debug_print = "R: nonlocal for $local_part@$domain"
    driver = redirect
    domains = ! +local_domains
    allow_fail
    data = :fail: Mailing to remote domains not supported
    no_more

.endif


COND_LOCAL_SUBMITTER = "\
               ${if match_ip{$sender_host_address}{:@[]}\
                    {1}{0}\
                }"

real_local:
  debug_print = "R: real_local for $local_part@$domain"
  driver = accept
  domains = +local_domains
  condition = COND_LOCAL_SUBMITTER
  local_part_prefix = real-
  check_local_user
  transport = LOCAL_DELIVERY


system_aliases:
  debug_print = "R: system_aliases for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/opt/local/etc/exim/virtual/aliases}}
  .ifdef SYSTEM_ALIASES_USER
    user = SYSTEM_ALIASES_USER
  .endif
  .ifdef SYSTEM_ALIASES_GROUP
    group = SYSTEM_ALIASES_GROUP
  .endif
  .ifdef SYSTEM_ALIASES_FILE_TRANSPORT
    file_transport = SYSTEM_ALIASES_FILE_TRANSPORT
  .endif
  .ifdef SYSTEM_ALIASES_PIPE_TRANSPORT
    pipe_transport = SYSTEM_ALIASES_PIPE_TRANSPORT
  .endif
  .ifdef SYSTEM_ALIASES_DIRECTORY_TRANSPORT
    directory_transport = SYSTEM_ALIASES_DIRECTORY_TRANSPORT
  .endif


userforward:
  debug_print = "R: userforward for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  check_local_user
  file = $home/.forward
  require_files = $local_part:$home/.forward
  no_verify
  no_expn
  check_ancestor
  allow_filter
  forbid_smtp_code = true
  directory_transport = address_directory
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply
  skip_syntax_errors
  syntax_errors_to = real-$local_part@$domain
  syntax_errors_text = \
    This is an automatically generated message. An error has\n\
    been found in your .forward file. Details of the error are\n\
    reported below. While this error persists, you will receive\n\
    a copy of this message for every message that is addressed\n\
    to you. If your .forward file is a filter file, or if it is\n\
    a non-filter file containing no valid forwarding addresses,\n\
    a copy of each incoming message will be put in your normal\n\
    mailbox. If a non-filter file contains at least one valid\n\
    forwarding address, forwarding to the valid addresses will\n\
    happen, and those will be the only deliveries that occur.


procmail:
  debug_print = "R: procmail for $local_part@$domain"
  driver = accept
  domains = +local_domains
  check_local_user
  transport = procmail_pipe
  # emulate OR with "if exists"-expansion
  require_files = ${local_part}:\
                  ${if exists{/etc/procmailrc}\
                    {/etc/procmailrc}{${home}/.procmailrc}}:\
                  +/usr/bin/procmail
  no_verify
  no_expn


maildrop:
  debug_print = "R: maildrop for $local_part@$domain"
  driver = accept
  domains = +local_domains
  check_local_user
  transport = maildrop_pipe
  require_files = ${local_part}:${home}/.mailfilter:+/usr/bin/maildrop
  no_verify
  no_expn


local_user:
  debug_print = "R: local_user for $local_part@$domain"
  driver = accept
  domains = +local_domains
  check_local_user
  local_parts = ! root
  transport = LOCAL_DELIVERY
  cannot_route_message = Unknown user


mail4root:
  debug_print = "R: mail4root for $local_part@$domain"
  driver = redirect
  domains = +local_domains
  data = /var/mail/root
  file_transport = address_file
  local_parts = root
  user = exim
  group = exim


######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################
begin transports

address_file:
  debug_print = "T: address_file for $local_part@$domain"
  driver = appendfile
  delivery_date_add
  envelope_to_add
  return_path_add


address_pipe:
  debug_print = "T: address_pipe for $local_part@$domain"
  driver = pipe
  return_fail_output


address_reply:
  debug_print = "T: autoreply for $local_part@$domain"
  driver = autoreply


mail_spool:
  debug_print = "T: appendfile for $local_part@$domain"
  driver = appendfile
  file = /var/mail/$local_part
  delivery_date_add
  envelope_to_add
  return_path_add
  group = mail
  mode = 0660
  mode_fail_narrower = false


maildir_home:
  debug_print = "T: maildir_home for $local_part@$domain"
  driver = appendfile

  .ifdef MAILDIR_HOME_MAILDIR_LOCATION
    directory = MAILDIR_HOME_MAILDIR_LOCATION
  .else
    directory = $home/Maildir
  .endif

  .ifdef MAILDIR_HOME_CREATE_DIRECTORY
    create_directory
  .endif

  .ifdef MAILDIR_HOME_CREATE_FILE
    create_file = MAILDIR_HOME_CREATE_FILE
  .endif

  delivery_date_add
  envelope_to_add
  return_path_add
  maildir_format

  .ifdef MAILDIR_HOME_DIRECTORY_MODE
    directory_mode = MAILDIR_HOME_DIRECTORY_MODE
  .else
    directory_mode = 0700
  .endif

  .ifdef MAILDIR_HOME_MODE
    mode = MAILDIR_HOME_MODE
  .else
    mode = 0600
  .endif

  mode_fail_narrower = false

  # This transport always chdirs to $home before trying to deliver. If
  # $home is not accessible, this chdir fails and prevents delivery.
  # If you are in a setup where home directories might not be
  # accessible, uncomment the current_directory line below.
  # current_directory = /


procmail_pipe:
  debug_print = "T: procmail_pipe for $local_part@$domain"
  driver = pipe
  path = "/bin:/usr/bin:/usr/local/bin"
  command = "/usr/bin/procmail"
  return_path_add
  delivery_date_add
  envelope_to_add


.ifdef DCconfig_internet

  DKIM_DOMAIN = ${sender_address_domain}
  DKIM_FILE = CONFDIR/domains/dkim/DKIM_DOMAIN.pem
  DKIM_PRIVATE_KEY = ${if exists{DKIM_FILE}{DKIM_FILE}{0}}
  DKIM_SELECTOR = dkim_signature_id
  DKIM_CANON = relaxed
  DKIM_STRICT = true

  remote_smtp:
    debug_print = "DEBUG T: remote_smtp for $local_part@$domain"
    driver = smtp
    tls_verify_certificates = MAIN_TLS_VERIFY_CERTIFICATES

    .ifndef IGNORE_SMTP_LINE_LENGTH_LIMIT
      message_size_limit = ${if > {$max_received_linelength}{998} {1}{0}}
    .endif
    .ifdef REMOTE_SMTP_HOSTS_AVOID_TLS
      hosts_avoid_tls = REMOTE_SMTP_HOSTS_AVOID_TLS
    .endif
    .ifdef REMOTE_SMTP_HEADERS_REWRITE
      headers_rewrite = REMOTE_SMTP_HEADERS_REWRITE
    .endif
    .ifdef REMOTE_SMTP_RETURN_PATH
      return_path = REMOTE_SMTP_RETURN_PATH
    .endif
    .ifdef REMOTE_SMTP_HELO_DATA
      helo_data=REMOTE_SMTP_HELO_DATA
    .endif
    .ifdef DKIM_DOMAIN
      dkim_domain = DKIM_DOMAIN
    .endif
    .ifdef DKIM_SELECTOR
      dkim_selector = DKIM_SELECTOR
    .endif
    .ifdef DKIM_PRIVATE_KEY
      dkim_private_key = DKIM_PRIVATE_KEY
    .endif
    .ifdef DKIM_CANON
      dkim_canon = DKIM_CANON
    .endif
    .ifdef DKIM_STRICT
      dkim_strict = DKIM_STRICT
    .endif
    .ifdef DKIM_SIGN_HEADERS
      dkim_sign_headers = DKIM_SIGN_HEADERS
    .endif
    .ifdef TLS_DH_MIN_BITS
      tls_dh_min_bits = TLS_DH_MIN_BITS
    .endif
    .ifdef REMOTE_SMTP_TLS_CERTIFICATE
      tls_certificate = REMOTE_SMTP_TLS_CERTIFICATE
    .endif
    .ifdef REMOTE_SMTP_PRIVATEKEY
      tls_privatekey = REMOTE_SMTP_PRIVATEKEY
    .endif

.endif


.ifdef DCconfig_mailgun

  mailgun_smtp:
    driver = smtp
    hosts_try_auth = smtp.mailgun.org

.endif


address_directory:
  debug_print = "T: address_directory for $local_part@$domain"
  driver = appendfile
  delivery_date_add
  envelope_to_add
  return_path_add
  check_string = ""
  escape_string = ""
  maildir_format

######################################################################
#                      RETRY CONFIGURATION                           #
######################################################################
begin retry

# Address or Domain    Error       Retries
# -----------------    -----       -------
*                      *           F,2h,15m; G,16h,1h,1.5; F,4d,6h

######################################################################
#                      REWRITE CONFIGURATION                         #
######################################################################
begin rewrite
######################################################################